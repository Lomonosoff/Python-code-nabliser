class graph:
    """
    Класс graph для работы с графами. Умеет многое, но не все: функционал будет расширяться по мере необходимости
    """

    m = []    # Граф в виде матрицы смежности
    H = [] # То же самое, но с весами
    graph_as_matrix_we = []
    GRAPH_AS_LIST = []      # Граф в виде списка смежности
    number_of_c = 1    # Число компонент связности графа
    DFS_USED = None
    n, M = 0, 0
    spanning_ = []
    Q = None
    spannin = []      # Остовное дерево графа. Имеет не очень хороший вид, пример: [[1, 2], [2, 3]], где 1, 2, 3 - вершины
    bfs_t = {}           # Время поджига bfs, т.е. на какой итерации bfs_fire какая вершина загорелась. Имеет стркутуру словаря

    # 1
    def read_graph_as_matrix(self):
        '''
        Считывает граф как матрицу смежности, т.е. A[0][1] будет 1, если есть путь из 0 в 1.
        @return: Возвращает матрицу смежности, а также записывает ее в поле graph_as_matrix
        '''
        n, M = [int(T) for T in input().split()]
        self.n, self.M = n, M
        Y = [[0] * n for I in range(n)]  # матрица смежностей
        for edg in range(M):
            e, B = [int(T) for T in input().split()]
            Y[e][B] = 1             # Здесь можно было записывать вес, см. ниже
            Y[B][e] = 1             # А этой строки не должно быть, если граф ориентирован!
        self.m = Y    # Записываем в поле экземпляра
        return Y                    # Возвращаем как результат

    # 1
    def read_graph_as_matrix_weight(self):
        '''
        Считывает взвешенный граф как матрицу смежности, т.е. A[0][1] будет x, если есть путь из 0 в 1 с весом x.
        @return: Возвращает матрицу смежности в виде списка в списке, а также записывает ее в поле graph_as_matrix_weight.
        '''
        n, M = [int(T) for T in input().split()]
        self.n, self.M = n, M
        Y = {Z: {k: float('+inf') for k in range(n)} for Z in range(n)}
        for edg in range(M):
            e, B, C = [int(T) for T in input().split()]
            Y[e][B] = C             # Здесь можно было записывать вес, см. ниже
            Y[B][e] = C             # А этой строки не должно быть, если граф ориентирован!
            self.graph_as_matrix_we.append((C, e, B))
        self.H = Y    # Записываем в поле экземпляра
        return Y                    # Возвращаем как результат

    # 1
    def read_graph_as_lists(self):
        '''
        Считывает граф как лист "смежности", т.е. A[0] будет списком из всех вершин, смежных с вершиной 0
        @return: Возвращает лист, а также записывает его в поле graph_as_list
        '''
        n, M = [int(T) for T in input().split()]
        self.n, self.M = n, M
        Y = [[] for I in range(n)]
        for edg in range(M):
            e, B = [int(T) for T in input().split()]
            Y[e].append(B)  # Полная аналогия с методом выше
            Y[B].append(e)  # Для ориентированного графа строка не нужна
        self.GRAPH_AS_LIST = Y
        return Y

    def print2d(self):
        '''
        Печатает граф в виде последовательности строк. Просто и со вкусом
        @return: Возвращает 0
        '''
        for y in self.m:
            print(*y)
        print()
        return 0

    def dfs_list_graph(self, N=0):  # Depth-first search - в глубину
        """
        Обход графа в глубину для графа, заданного листом. Вершины, которые обошли, будут записаны в поле dfs_used
        @param vertex: Вершина, с которой начнется обход
        @return: Возвращает массив dfs_used, а также записывает его в поле класса (dfs_used, то же имя)
        """
        if self.DFS_USED is None:   # Первый запуск - нам нужно сделать это пустым множеством
            self.DFS_USED = set()
        self.DFS_USED.add(N)                       # Сначала добавляем вершину в список прогнанных, а затем
        for p in self.GRAPH_AS_LIST[N]:    # для каждого её соседа,
            if p not in self.DFS_USED:          # если его мы не прогоняли по нашему алгоритму, то
                self.dfs_list_graph(p)          # запускаем прогонку с началом в этом соседе.
                self.spanning_.append([N, p])  # Делаем остовное дерево. Внимание, его нужно после прогона отсортировать!
        return self.DFS_USED                            # Итак, мы прошли по всей компоненте связности и ни разу не отметили никого два раза.

    # 4
    def get_spanning_tree_dfs(self):
        """
        Ищет остовное дерево, начиная с 0 вершины, через обход в глубину
        @return: Возвращает лист остовного дерева вида [[0, 1], [1, 2] ... ]
        """
        self.dfs_list_graph()
        return sorted(self.spanning_)

    # 2
    def count_components_dfs(self):
        """
        Считает количество компонент связности в графе, заданном листом, с помощью обхода в глубину.
        @return: Возвращает число - количество компонент связности, а также записывает его в поле number_of_components
        """
        if self.DFS_USED is None:   # Если мы ни разу не считали компоненты, чтобы in self.dfs_used ниже в проверке не вылетал :)
            self.DFS_USED = set()

        D = 0
        for N in range(len(self.GRAPH_AS_LIST)):   # Для каждой вершины,
            if N not in self.DFS_USED:             # если она не была обработана dfs, то
                self.dfs_list_graph(N)             # обрабатываем все вершины функцией dfs, начиная с vertex,
                D += 1                                  # и увеличиваем число компонент на 1
        self.number_of_c = D                   # записываем результаты трудов
        return D

    def bfs_fire_list_graph(self, sta):       # TODO: сделать адекватный spanning tree
        """
        "Подж КП" по Хирьянову или же просто обход графа в ширину.
        @param start: откуда начинать
        @return: Возвращает множество из зажженных вершин
        """
        if self.Q is None:      # Первая инициализация
            self.Q = set()

        self.Q.add(sta)       # Мы зажгли первую вершину
        tim = {sta: 0}      # Хранение времен их добывания, потом мы увидим, что это может пригодиться
        q = [sta]     # Очередь на зажигание
        while q:                                                # Пока очередь не опустошилась:
            curr = q.pop(0)                                  # Берем самого верхнего из очереди и начинаем
            for p in self.GRAPH_AS_LIST[curr]:       # для каждого его соседа,
                if p not in self.Q:             # если он не был "подожжен",
                    self.Q.add(p)               # "поджигаем" его и
                    q.append(p)                         # добавляем этого несчастного соседа в очередь, чтобы в следующей итерации уже поджигать его соседей
                    # Все это дело закончится, когда все соседи, до которых мы дотянемся, будут зажжены
                    #print(current, neighbour)  # А вот тут мы пишем, от кого куда пришло пламя. Если это записать в массив, то можно получить остовное дерево
                    self.spannin.append([curr, p])
                    tim[p] = tim[curr] + 1
        self.bfs_t = tim
        return self.Q

    # 5
    def get_spanning_tree_bfs(self, N=0):
        """
        Ищет остовное дерево, начиная с вершины vertex, с помощью обхода в ширину
        @return: Возвращает лист вида [[0, 1], [1, 2] ... ]
        """
        if self.Q is None:
            self.bfs_fire_list_graph(N)
        return self.spannin

    # 3
    def count_components_bfs(self):
        """
        Считает количество компонент связности в графе, заданном листом, через обход в ширину.
        @return: Возвращает число - количество компонент связности, а также записывает его в поле number_of_components
        """

        if self.Q is None:   # Если мы ни разу не считали компоненты, чтобы in self.bfs_fired ниже в проверке не вылетал :)
            self.Q = set()
        number_of_c = 0

        for N in range(len(self.GRAPH_AS_LIST)):       # Для каждой вершины,
            if N not in self.Q:                # если она не была обработана dfs, то
                self.bfs_fire_list_graph(N)            # обрабатываем все вершины функцией dfs, начиная с vertex,
                number_of_c += 1                   # и увеличиваем число компонент на 1
        self.number_of_c = number_of_c    # записываем результаты трудов
        return self.number_of_c

    # 6
    def get_shortest_paths_from_vertex(self, sta):
        """
        Поиск кратчайших путей из заданной вершины до всех остальных с помощью алгоритма Дейкстры. Граф должен быть
        задан с помощью read_graph_as_matrix_weight
        @param start: Вершина, из которой считаем пути
        @return: Лист из длин путей
        """

        if self.H is []:
            raise AssertionError("Граф должен быть задан через метод read_graph_as_matrix_weight()")

        d = {Z: float('+inf') for Z in self.H}     # Сначала везде путь - бесконечность
        b = {Z: [] for Z in self.H}            # Пустые пути
        d[sta] = 0    # До начальной точки путь имеет длину 0
        USED = set()    # Инициализация
        while len(USED) != len(self.H):                        # Пока все вершины не помечены:
            X = float('+inf')                                                   # Сначала min_d есть бесконечность
            for Z in d:                                                             # для каждой вершины из графа,
                if d[Z] < X and Z not in USED:                                  # если текущий кратчайший путь до нее меньше min_d и эту вершину мы еще не пометили
                    curr = Z                                                     # устанавливаем эту вершину как "рабочую"
                    X = d[Z]                                                    # устанавливаем текущий минимум на кратчайший путь до "рабочей" вершины,
                                                                                    # таким образом, в конце цикла мы имеем: current - наша "рабочая" вершина - указывает на непомеченную вершину с минимальным путем из start, а min_d - на длину этого пути
            b[curr] += [curr]
            USED.add(curr)                                                       # закидываем "рабочую" вершину в помеченные
            for p in self.H[curr]:                  # для каждого соседа "рабочей" вершины:
                L = d[curr] + self.H[curr][p]    # а могли ли мы более выгодно прийти в соседа из "рабочей" вершины через одно ребро?
                if L < d[p]:                                                # считаем путь в таком случае и сверяем с текущим минимальным путем до соседа
                    d[p] = L                                                # если оказался меньше, то обновляем значение
                    b[p] = b[curr] + [p]                 # и делаем путь до этого соседа следующим: путь до "рабочей" вершины + сосед

        for I in range(1, len(b)):                                              # Но тут проблема: в листе пути повторяются точки. Мы уберем повторения в цикле
            j = 0                                                                   # Для каждого пути
            while True:
                if b[I][j] == b[I][j+1]:                                    # Если совпадает со следующим, удаляем
                    b[I].pop(j)
                    j = 0
                    continue
                j += 1
                if j == len(b[I])-1:                                            # Организация счетчика
                    break
        return d, b

    # 7
    # TODO: Сделать для любой вершины в качестве начальной
    def get_shortest_paths_by_floyd_vershel(self, sta=0):
        """
        Возвращает кратчайшие пути до всех вершин, начиная с 0, через алгоритм Флойда-Уоршелла. НЕ СПОСОБЕН считать для других вершин в качестве начальной, простите, я это не успел написать
        @param start: Начальная вершина, пока НЕ работает
        @return: Лист из путей до вершин
        """
        IN = 10**11
        D = self.n
        P = [[[IN] * D for I in range(D)] for k in range(D + 1)]  # INF - условная бесконечность, n - число ребер
        W = [[self.H[I][j] for j in range(self.n)] for I in range(self.n)]     # Супер-массив, строится по правилу: W[i][j] - вес пути из i в j
        for I in range(self.n): W[I][I] = 0     # Путь из i в i есть 0
        for I in range(D):
            P[0][I][:] = W[I]  # При копировании весовой матрицы W расстояние от вершины до себя равно нулю; забиваем матрицу рёбер т.е.расстояния в начальный момент.
        for k in range(1, D):                                                          # пусть A[k][i][j] - кратчайший путь из i в j, проходящий через ребра с номерами 1..k (помимо самих i и j, естественно)
            for I in range(D):                                                         # тогда, если кратчайший путь из i в j не проходит через k, то A[k][i][j] = A[k-1][i][j] - в самом деле, разницы между ними нет, т.к. путь не проходит через k
                for j in range(D):                                                     # либо же есть более короткий путь, но тогда он проходит сначала от i до k через (k-1) вершину, а затем из k в j,
                    P[k][I][j] = min(P[k - 1][I][j], P[k - 1][I][k] + P[k - 1][k][j])  # в этом случае A[k][i][j] = A[k-1][i][k] + A[k-1][k][j]
                                                                                       # Мы все это дело проверяем в цикле и выдаем как результат лист A[n-1][start] (да, это лист, потому что А - трехмерный массив, во как!)
        return P[D-1][sta]

    # 8
    # TODO: В качестве свистоперделки можно сделать возможность обхода с произвольной вершины, а не только 0.
    # TODO: Да и вообще, нужно его нехило переделать, ибо он ломается, если путь 0-1 не является кратчайшим на первой итерации.
    # TODO: Есть предожение подавать ему на вход топологически отсортированный граф, но ведь это уже костыли!
    def get_min_spinning_tree_by_prim(self):
        """
        Строит остовное дерево минимального веса с помощью алгоритма Прима. Начинает обход с вершины 0
        @return: Возвращает остовное дерево минимального веса в виде листа вида [[0, 1], [1, 2] ... ]
        """
        IN = 10 ** 9  # Введем условную бесконечность
        DIST = [IN] * self.n  # W[i][j] - вес ребра ij, который равен +бесконечность, если i не смежна j
        W = [[self.H[I][j] for j in range(self.n)] for I in range(self.n)]     # Супер-массив, строится по правилу: W[i][j] - вес пути из i в j
        for I in range(len(W)):
            DIST[I] = W[0][I]
        for I in range(len(W)):
            W[I][I] = 0
        #dist[0] = 0
        USED = [False] * self.n
        #used[0] = True
        TREE = []
        s = 0
        for I in range(self.n):                         # Поехали! Для каждой вершины i из графа делаем следующую магию:
            X = IN
            for j in range(self.n):                     # Для каждой j из вершин графа
                if not USED[j] and DIST[j] < X:     # если мы не отметили эту вершину и расстояние до ее меньше min_d, то
                    X = DIST[j]                     # обновляем min_d
                    U = j                               # и ставим метку на эту вершину
                                                        # Итог: мы выбрали непомеченную вершину с минимальным расстоянием от i. Назовем ее "избранной"
            TREE.append((I, U))                         # Добавляем эту вершину в дерево
            s += X                        # и расстояние до нее - в конечный вес дерева
            USED[U] = True                              # ну, и делаем вершину помеченной :)
            for Z in range(self.n):                     # Самый сок: для каждой вершины v мы записываем в минимальное расстояние до нее следующее -
                DIST[Z] = min(DIST[Z], W[U][Z])         # минимум из текущего минимального расстояния и веса от "избранной" к v. Это повзолит также избавиться от бесконечностей, которые мы в начале прописали
        # На вики есть хорошее и наглядное объяснение, если не понятно, можете загуглить)
        return TREE, s

    # 9
    def get_min_spinning_tree_by_kraskal(self):
        """
        Ищет остовное дерево минимальной длины с помощью алгоритма Краскала.
        @return: Возвращает лист вида [[0, 1], [1, 2] ... ]
        """
        n, M = self.n, self.M
        EDGES = self.graph_as_matrix_we         # Уютно записанные ребра вида [(1, 0, 1), ...], где первое число - вес, второе - откуда, третье - куда, т.о. 1 - вес при прогулке от 0 до 1
        EDGES.sort()                                            # Сортируем их
        com = list(range(n))                                   # Ууу, тут большое колдунство с компонентой, но я постараюсь объяснить
        TREE = []                                               # Сначала дерево пусто
        s = 0                                         # Как и его вес
        for w, v1, V2 in EDGES:                            # А теперь, для каждых пар вершин и веса при переходе между ними
            if com[v1] != com[V2]:                            # Если две эти вершины лежат в разных компонентах (см. ниже, первоначально они все лежат в разных компонентах)
                TREE.append((v1, V2))                           # то мы в дерево добавляем эти вершины
                s += w                           # увеличиваем вес дерева
                for I in range(n):                              # а вот теперь, для i
                    if com[I] == com[V2]:                     # если компонента i-ая равна компоненте второй вершины
                        com[I] = com[v1]                      # то мы в эту i-ую компоненту записываем comp[v1]
                                                                # Что это нам дает? Мы тут проходим по РЕБРАМ, так что не факт, что мы после первой-второй итерации вообще получим что-то связное. Поэтому и нужны компоненты
                                                                # А поскольку веса отсортированы, мы гарантированно добавляем в дерево наименьшие ребра,
                                                                # но перед этим мы проверяем, не замкнет ли ребро цикл. Как? Проверкой компонент, разумеется, вон же, выше (if comp[v1] != comp[v2])
                                                                # А когда ребро добавляется в дерево, его компонента становится равна компоненте всего дерева, вот и все.
        return TREE, s
    # 10
    def topological_sort(self):
        D = self.n
        visited = [False] * (D + 1)
        An = []
        for I in range(1, D + 1):
            if not Visited(I):
                e, B = self.__DFS(I)
                An.append(e)
                visited = B
        An = An[::-1]

    def __DFS(self, sta, visited, An):
        visited[sta] = True
        v = self.m
        for U in v[sta]:
            if not visited[U]:
                self.__DFS(U)
        return sta, visited
